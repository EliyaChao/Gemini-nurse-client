<!DOCTYPE html>
<html lang="zh-TW"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>è­·ç†å¸«èˆ‡ç—…äººå°è©±</title> <!-- è¼‰å…¥ Tailwind CSS (ç”¨æ–¼å¿«é€Ÿä½ˆå±€) --> <script src="https://cdn.tailwindcss.com"></script> <!-- è¼‰å…¥ Noto Sans TC å­—é«” --> <link href="https://www.google.com/search?q=https://fonts.googleapis.com/css2%3Ffamily%3DNoto%2BSans%2BTC:wght%40400%3B700%26display%3Dswap" rel="stylesheet"> </head> <body class="min-h-screen flex items-center justify-center p-4"> <div class="chat-container"> <style> /* èŠå¤©ä»‹é¢æ¨£å¼ */ body { font-family: "Noto Sans TC", sans-serif; background-color: #f3f5f7; margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; }
        .chat-container {
            width: 100%;
            max-width: 600px;
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            height: 90vh; /* ç¢ºä¿ä½”æ“šå¤§éƒ¨åˆ†è¦–çª— */
        }

        #chat-box {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            background-color: #fafafa;
            display: flex;
            flex-direction: column;
            gap: 10px;
            scroll-behavior: smooth;
        }

        /* éš±è—æ»¾å‹•æ¢ */
        #chat-box::-webkit-scrollbar {
            display: none;
        }
        #chat-box {
            -ms-overflow-style: none; /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        .message {
            max-width: 70%;
            padding: 10px 15px;
            border-radius: 20px;
            line-height: 1.5;
            position: relative;
            opacity: 1;
        }

        .user {
            align-self: flex-end;
            background-color: #d1e7ff; /* è­·ç†å¸«ï¼šè¼ƒæ·¡çš„è—è‰² */
            color: #1f2937;
            border-bottom-right-radius: 4px; 
        }

        .assistant {
            align-self: flex-start;
            background-color: #f9e79f; /* ç—…äººï¼šæ˜é¡¯çš„æ·ºé»ƒè‰² */
            color: #1f2937;
            border-bottom-left-radius: 4px;
        }

        .message-container {
            display: flex;
            align-items: flex-end;
            gap: 5px;
        }

        .user .message-container {
            flex-direction: row-reverse;
        }

        /* å°‡ send button æ¨£å¼å°æ‡‰åˆ° #send-button */
        #send-button {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            background-color: #0078d4;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #send-button:hover:not(:disabled) {
            background-color: #005fa3;
        }

        #send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .input-area {
            display: flex;
            gap: 10px;
        }

        #user-input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 1em;
        }

        /* ç—…äººé ­åƒ */
        .assistant-avatar {
            font-size: 1.2em;
        }
    </style>

    <header class="p-4 bg-gray-800 text-white rounded-t-lg shadow-lg -mt-5 -mx-5 mb-5">
        <h1 class="text-xl font-bold">è­·ç†å¸«èˆ‡ç—…äººå°è©±æ¨¡æ“¬ (ç¨ç«‹é‹è¡Œç‰ˆ)</h1>
        <p class="text-sm opacity-80">æ‚¨çš„è©±èªï¼ˆè­·ç†å¸«ï¼‰å°‡æœƒè§¸ç™¼ç—…äººçš„ä¸åŒåæ‡‰ã€‚æ‰€æœ‰é‚è¼¯éƒ½åœ¨é€™å€‹å–®ä¸€æª”æ¡ˆä¸­ã€‚</p>
    </header>

    <div id="chat-box">
        <!-- åˆå§‹æ­¡è¿è¨Šæ¯å°‡ç”± JavaScript å‹•æ…‹è¼‰å…¥ -->
    </div>

    <footer class="input-area border-t border-gray-200 pt-4">
        <form id="chat-form" class="flex flex-grow space-x-3">
            <input type="text" id="user-input" placeholder="è¼¸å…¥è­·ç†å¸«çš„è©±èª..."
                   class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150"
                   required autocomplete="off">
            <button type="submit" id="send-button"
                    class="shadow-md transition duration-200 disabled:opacity-50"
                    title="å‚³é€è¨Šæ¯">
                å‚³é€
            </button>
        </form>
        <div id="loading-indicator" class="hidden text-center text-sm text-gray-500 mt-2">
            ç—…äººæ­£åœ¨æ€è€ƒ...
        </div>
        <div id="mock-status" class="hidden text-center text-xs mt-2 p-1 rounded-md"></div>
    </footer>
</div>

<script>
    // ------------------- ğŸ”¹ æ¨¡æ“¬å¾Œç«¯é‚è¼¯èˆ‡è¨­å®š ğŸ”¹ -------------------
    const MODEL_NAME = "gemini-2.5-flash";

    // ğŸš¨ é€™æ˜¯é—œéµï¼åœ¨ Canvas ç’°å¢ƒä¸­ï¼ŒAPI Key ç•™ç©ºï¼Œç³»çµ±æœƒè‡ªå‹•æä¾›
    const apiKey = "";
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;

    const SYSTEM_PROMPT = "ä½ æ˜¯ä¸€ä½ç²¾ç¥ç§‘ç—…äººï¼Œæ­£è©¦è‘—ç†è§£è­·ç†å¸«ç°¡çŸ­ã€æ¨¡ç³Šçš„è©±èªã€‚ä½ çš„å›æ‡‰è¦è¡¨ç¾å‡ºå›°æƒ‘ã€è¼•å¾®çš„ååŸ·æˆ–ç„¦æ…®ï¼Œä¾‹å¦‚ï¼š'ä½ åœ¨èªªä»€éº¼ï¼Ÿ'ï¼Œ'é€™è·Ÿé‚£å€‹æ±è¥¿æœ‰é—œå—ï¼Ÿ'ã€‚ä½ çš„å›ç­”å¿…é ˆç°¡çŸ­ã€‚";

    // å…§åµŒ Mock æ•¸æ“šï¼Œä½œç‚ºå‰ç«¯çš„çŸ¥è­˜åº« (ç„¡æ³•æŒä¹…åŒ–å„²å­˜)
    let MOCK_RESPONSES = [
        { keywords: [{ word: "é‹å‹•", weight: 1 }, { word: "æ—©ä¸Š", weight: 1 }, { word: "å¿™", weight: 1 }], reply: "é‹å‹•ï¼Ÿæ˜¯...æ˜¯ä»–å€‘åœ¨ç›£è¦–æˆ‘å—ï¼Ÿæˆ‘çš„è‚Œè‚‰è£¡æœ‰æ±è¥¿ã€‚" },
        { keywords: [{ word: "å¿ƒæƒ…ä¸å¥½", weight: 1 }, { word: "ä¸æƒ³åš", weight: 1 }, { word: "æƒ…ç·’", weight: 1 }], reply: "ä»€éº¼æ„Ÿå—ï¼Ÿä½ æ˜¯èªª...æˆ‘è¢«æ“æ§çš„æƒ…ç·’ï¼Ÿåˆ¥å‡è£ä½ æ‡‚ã€‚" },
        { keywords: [{ word: "å ±å‘Š", weight: 1 }, { word: "ä»Šæ™š", weight: 1 }, { word: "å¤ªæ™š", weight: 1 }, { word: "ç´¯", weight: 1 }], reply: "å ±å‘Šï¼Ÿé‚£äº›ç§˜å¯†æ–‡ä»¶...æˆ‘ä¸èƒ½å¯«ï¼Œä»–å€‘æœƒç™¼ç¾çš„ï¼" },
        { keywords: [{ word: "åˆé¤", weight: 1 }, { word: "é¸æ“‡", weight: 1 }, { word: "å¥åº·", weight: 1 }], reply: "é£Ÿç‰©...é€™è£¡çš„é£Ÿç‰©éƒ½æœ‰æ¯’ï¼Œæˆ‘ä¸è¦åƒï¼Œåˆ¥é€¼æˆ‘ï¼" },
        { keywords: [{ word: "æ™šé¤", weight: 1 }, { word: "ç°¡å–®", weight: 1 }, { word: "å®¶å¸¸", weight: 1 }], reply: "ç°¡å–®ï¼Ÿç°¡åŒ–æˆ‘çš„å­˜åœ¨å—ï¼Ÿä½ åœ¨èªªä»€éº¼ï¼Ÿ" },
        { keywords: [{ word: "ç¡çœ ", weight: 1 }, { word: "æ™šä¸Š", weight: 1 }, { word: "ä¸è¶³", weight: 1 }], reply: "æ™šä¸Š...æˆ‘ä¸€é–‰çœ¼ï¼Œé‚£äº›è²éŸ³å°±ä¾†äº†ï¼Œä½ å«æˆ‘æ€éº¼ç¡ï¼Ÿ" },
        { keywords: [{ word: "æœƒè­°", weight: 1 }, { word: "ç·Šå¼µ", weight: 1 }, { word: "æº–å‚™", weight: 1 }], reply: "æœƒè­°å®¤è£¡æœ‰æ”åƒé ­ï¼ä½ è®“æˆ‘å»ï¼Ÿæ˜¯è¦é™·å®³æˆ‘å—ï¼Ÿ" },
        { keywords: [{ word: "å­¸ç¿’", weight: 1 }, { word: "è‹±æ–‡", weight: 1 }, { word: "å–®å­—", weight: 1 }], reply: "å­¸ç¿’ï¼Ÿä»–å€‘è®“æˆ‘å­¸é€™äº›å¯†ç¢¼ï¼Œä½ ä¹Ÿè¦å¹«ä»–å€‘å—ï¼Ÿ" },
        { keywords: [{ word: "é‹å‹•", weight: 1 }, { word: "ä¸‹åˆ", weight: 1 }, { word: "æ”¾é¬†", weight: 1 }], reply: "æ”¾é¬†ï¼Ÿæˆ‘éš¨æ™‚éƒ½å¿…é ˆä¿æŒè­¦è¦ºï¼Œä½ å«æˆ‘æ€éº¼æ”¾é¬†ï¼Ÿ" },
        { keywords: [{ word: "å¿ƒæƒ…", weight: 1 }, { word: "ä½è½", weight: 1 }, { word: "éŸ³æ¨‚", weight: 1 }], reply: "éŸ³æ¨‚ï¼Ÿé‚£æ ¹æœ¬ä¸æ˜¯éŸ³æ¨‚ï¼Œé‚£æ˜¯ä»–å€‘é€éé›»æ³¢åœ¨å‚³é”è¨Šæ¯ï¼" },
        { keywords: [{ word: "ä½ å¥½", weight: 3 }, { word: "æ„Ÿè¦º", weight: 3 }, { word: "æ€éº¼æ¨£", weight: 3 } ], reply: "æˆ‘... æˆ‘é‚„å¥½ï¼Œè­·ç†å¸«ã€‚ä½ è¦ºå¾—æˆ‘çœ‹èµ·ä¾†é‚„å¥½å—ï¼Ÿ" },
        { keywords: [{ word: "æ—©é¤", weight: 1 }, { word: "åƒäº†", weight: 1 }, { word: "è—¥", weight: 1 } ], reply: "æ—©é¤ï¼Ÿå¥½åƒæœ‰... å°ï¼Œæˆ‘åƒäº†ã€‚é‚£é¡†è—è‰²çš„å°è—¥ä¸¸ï¼Œä»–å€‘èªªå¯ä»¥å¹«æˆ‘è¶•èµ°é‚£äº›è²éŸ³ã€‚" },
        { keywords: [{ word: "æ™šä¸Š", weight: 1 }, { word: "ç¡å¾—", weight: 1 }, { word: "å¥½å—", weight: 1 } ], reply: "ï¼ˆæ“è‘—æ‰‹ï¼‰æ˜¨æ™š... æˆ¿é–“çš„ç‡ˆä¸€ç›´é–ƒçˆï¼Œæœ‰äººä¸€ç›´åœ¨èµ°å»Šä¸Šèµ°å‹•ã€‚æˆ‘å¹¾ä¹æ²’ç¡ã€‚" },
        { keywords: [{ word: "å¿ƒæƒ…", weight: 5 }, { word: "èŠèŠ", weight: 1 }, { word: "ä»Šå¤©", weight: 5 } ], reply: "æˆ‘çš„å¿ƒæƒ…... å°±åƒè¢«é–åœ¨é€™å€‹æˆ¿é–“è£¡çš„ä¸€éš»é³¥ã€‚ä½ è½è¦‹ä»–å€‘åœ¨è«‡è«–æˆ‘å—ï¼Ÿ" }
    ];

    // è¨ˆç®—åŒ¹é…åˆ†æ•¸
    function calculateMatchScore(mock, userMessage) {
        let score = 0;
        mock.keywords.forEach(kw => {
            if (userMessage.includes(kw.word)) {
                score += kw.weight || 1;
            }
        });
        return score;
    }

    // æå–é—œéµå­— (ç”¨æ–¼å‹•æ…‹å­¸ç¿’æ™‚å‰µå»ºæ–°çš„ Mock)
    function extractKeywords(text) {
        return text
            .replace(/[.,!?ï¼Œã€‚ï¼ï¼Ÿ\n]/g, " ")
            .split(/\s+/)
            .filter(word => word.length > 1)
            .map(word => ({ word, weight: 1 }));
    }

    // ------------------- ğŸ”¹ å‰ç«¯ DOM èˆ‡äº’å‹•é‚è¼¯ ğŸ”¹ -------------------
    const chatForm = document.getElementById('chat-form');
    const userInput = document.getElementById('user-input');
    const chatBox = document.getElementById('chat-box');
    const sendButton = document.getElementById('send-button');
    const loadingIndicator = document.getElementById('loading-indicator');
    const mockStatus = document.getElementById('mock-status');

    function appendMessage(sender, text, score) {
        const isUser = sender === 'user';
        
        const messageContainer = document.createElement('div');
        messageContainer.className = `message-container ${isUser ? 'justify-end' : 'justify-start'} w-full`;

        const bubble = document.createElement('div');
        bubble.className = `message shadow-sm ${isUser ? 'user' : 'assistant'}`;
        bubble.textContent = text;
        
        if (!isUser) {
            const avatar = document.createElement('div');
            avatar.className = 'assistant-avatar text-xl';
            avatar.textContent = 'ğŸ‘¤';
            messageContainer.appendChild(avatar);
        }

        messageContainer.appendChild(bubble);
        
        // åƒ…åœ¨ AI/Mock è¨Šæ¯æ™‚é¡¯ç¤ºåˆ†æ•¸
        if (!isUser && score !== undefined && score !== null) {
            const scoreSpan = document.createElement('span');
            scoreSpan.className = 'block mt-1 text-xs opacity-70';
            scoreSpan.textContent = `[åŒ¹é…åˆ†: ${score}]`;
            bubble.appendChild(scoreSpan);
        }
        
        chatBox.appendChild(messageContainer);
        chatBox.scrollTop = chatBox.scrollHeight;
    }

    function updateStatus(score, mockUsed) {
        mockStatus.classList.remove('hidden', 'bg-red-100', 'text-red-700', 'bg-green-100', 'text-green-700', 'bg-yellow-100', 'text-yellow-700');
        
        let statusText = `åŒ¹é…åˆ†æ•¸: ${score} - `;
        let statusClass = '';

        if (score >= 3 && mockUsed) {
            statusText += 'é«˜åˆ†åŒ¹é… (ä½¿ç”¨ Mock å›è¦†)';
            statusClass = 'bg-green-100 text-green-700';
        } else if (score === 2) {
            statusText += 'ä¸­åº¦åŒ¹é… (å›°æƒ‘å¼•å°)';
            statusClass = 'bg-yellow-100 text-yellow-700';
        } else if (score === 1) {
            statusText += 'ä½åº¦åŒ¹é… (è¿´é¿è¡Œç‚º/éš¨æ©Ÿ)';
            statusClass = 'bg-yellow-100 text-yellow-700';
        } else { // score === 0 (ä½¿ç”¨ AI æ¨¡å‹)
            statusText += 'ç„¡åŒ¹é… (ä½¿ç”¨ Gemini AI)';
            statusClass = 'bg-red-100 text-red-700';
        }

        mockStatus.textContent = statusText;
        mockStatus.classList.add(statusClass);
        mockStatus.classList.remove('hidden');
    }

    async function handleChat(userMessage) {
        // 1. æ‰¾åŒ¹é…åˆ†æ•¸æœ€é«˜ mock
        let bestMock = null;
        let highestScore = 0;

        MOCK_RESPONSES.forEach(m => {
            const score = calculateMatchScore(m, userMessage);
            if (score > highestScore) {
                highestScore = score;
                bestMock = m;
            }
        });

        let responseData = {
            reply: "",
            score: highestScore,
            mockUsed: false,
        };

        // 2. å¯¦ä½œ Mock é‚è¼¯
        if (highestScore >= 3 && bestMock) {
            // é—œéµå­—å¤§æ–¼æˆ–ç­‰æ–¼ 3 å€‹æ™‚ï¼Œä»¥æœ€ç¬¦åˆå¤šæ•¸é—œéµå­—åŒ¹é…ç¨‹åº¦é¸æ“‡ mock å„ªå…ˆå›æ‡‰
            responseData.reply = bestMock.reply;
            responseData.mockUsed = true;

            return responseData;

        } else if (highestScore === 2) {
            // é—œéµå­—åŒ¹é… 2 å€‹æ™‚ï¼Œçµ¦äºˆå›°æƒ‘å›æ‡‰
            responseData.reply = "ä½ ...ä½ æ˜¯åœ¨æš—ç¤ºä»€éº¼å—ï¼Ÿæˆ‘è½ä¸æ‡‚ã€‚";
            return responseData;
            
        } else if (highestScore === 1) {
            // é—œéµå­—ç¬¦åˆ 1 å€‹æ™‚ï¼Œéš¨æ©Ÿå›æ‡‰è¿´é¿è¡Œç‚º
            const lowScoreReplies = [
                "ï¼ˆä½é ­ï¼Œæ²‰é»˜ä¸èª...ï¼‰",
                "ï¼ˆçœ‹å‘çª—å¤–...ï¼‰",
                "ï¼ˆè‡ªè¨€è‡ªèªä¸ç†æœƒ....ï¼‰"
            ];
            const randomIndex = Math.floor(Math.random() * lowScoreReplies.length);
            responseData.reply = lowScoreReplies[randomIndex];

            return responseData;
        }

        // 3. ç„¡åŒ¹é… (highestScore = 0) - å‘¼å« Gemini API
        try {
            const payload = {
                contents: [
                    { role: "user", parts: [{ text: userMessage }] },
                ],
                config: {
                    systemInstruction: SYSTEM_PROMPT
                }
            };

            // ä½¿ç”¨ fetch å‘¼å« Gemini API
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                // æ‹‹å‡ºéŒ¯èª¤ï¼Œè®“ catch å€å¡Šè™•ç†
                throw new Error(`API error: ${response.status} ${response.statusText}`);
            }

            const result = await response.json();
            const generatedText = result.candidates?.[0]?.content?.parts?.[0]?.text || "ï¼ˆæ²‰é»˜...ï¼‰";

            responseData.reply = generatedText;

            // å‹•æ…‹å­¸ç¿’åŠ å…¥ mock (ä¸æŒä¹…åŒ–)
            const newKeywords = extractKeywords(userMessage);
            if (newKeywords.length >= 2 && generatedText !== "ï¼ˆæ²‰é»˜...ï¼‰") {
                const isDuplicate = MOCK_RESPONSES.some(m => m.reply === responseData.reply);
                if (!isDuplicate) {
                    MOCK_RESPONSES.push({ keywords: newKeywords, reply: responseData.reply, weight: 1 });
                }
            }

            return responseData;
        } catch (error) {
            console.error("Gemini API éŒ¯èª¤:", error);
            // éŒ¯èª¤å›è¦†ï¼ˆç¬¦åˆç—…äººè§’è‰²ï¼‰
            responseData.reply = "ï¼ˆç„¦æ…®åœ°ç’°é¡§å››å‘¨ï¼‰æ˜¯ä¸æ˜¯æœ‰äººåœ¨è½ï¼Ÿé€™è£¡ä¸èƒ½èªªï¼Œæˆ‘ä»€éº¼éƒ½ä¸çŸ¥é“ã€‚";
            return responseData;
        }
    }

    // è™•ç†è¡¨å–®æäº¤
    chatForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const message = userInput.value.trim();

        if (!message) return;

        appendMessage('user', message);
        userInput.value = '';

        sendButton.disabled = true;
        loadingIndicator.classList.remove('hidden');

        const responseData = await handleChat(message);

        appendMessage('ai', responseData.reply, responseData.score);
        updateStatus(responseData.score, responseData.mockUsed);

        sendButton.disabled = false;
        loadingIndicator.classList.add('hidden');
    });

    // åˆå§‹æ­¡è¿èªæ³•ï¼šé é¢è¼‰å…¥å¾Œç«‹å³æ’å…¥åˆå§‹æ­¡è¿è¨Šæ¯
    window.onload = () => {
         appendMessage('ai', 'æˆ‘æ˜¯ç—…äººã€‚ä½ ...ä½ æ˜¯èª°ï¼Ÿä½ æƒ³å°æˆ‘åšä»€éº¼ï¼Ÿ', null);
    };
</script>
</body> </html>

